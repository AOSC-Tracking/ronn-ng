#!/usr/bin/env ruby
require 'rdiscount'
require 'nokogiri'

class Ron
  attr_reader :filename, :data, :basename, :name, :section, :tagline

  def initialize(filename, &block)
    @filename = filename
    @reader = block || Proc.new { |f| File.read(f) }
    @data = @reader.call(filename)

    @basename = File.basename(filename)
    @name, @section =
      if @basename =~ /(\w+)\.(\d\w*)\.ron/
        [$1, $2]
      else
        [@basename[/\w+/], nil]
      end
  end

  # Construct a path to a file near the input file.
  def path(extension=nil)
    extension = nil if ['', 'roff'].include?(extension.to_s)
    name = "#{@name}.#{section}"
    name = "#{name}.#{extension}" if extension
    File.join(File.dirname(filename), name)
  end

  # Convert the document to :roff or :html
  def convert(format)
    send "to_#{format}"
  end

  # Convert the document to roff.
  def to_roff
    roff_filter(to_html_fragment)
  end

  # Convert the document to HTML and return result
  # as a string.
  def to_html
    layout_filter(to_html_fragment)
  end

  # Convert the document to HTML and return result
  # as a string. The HTML does not include <html>, <head>,
  # or <style> tags.
  def to_html_fragment
    definition_list_filter(markdown_filter(data))
  end

  # Apply the standard HTML layout template.
  def layout_filter(html)
    template_file = File.dirname(__FILE__) + "/ron/layout.html"
    template = File.read(template_file)
    eval("%Q{#{template}}", binding, template_file)
  end

  # Run markdown on the data and extract name, section, and
  # tagline.
  def markdown_filter(data)
    html = Markdown.new(data).to_html
    @tagline, html = html.split("</h1>\n", 2)
    @tagline.sub!('<h1>', '')

    # grab name and section from title
    if @tagline =~ /([\w_:-]+)\((\d\w*)\) -- (.*)/
      @name, @section = $1, $2
      @tagline = $3
    end

    "<h2 id='NAME'>NAME</h2>\n" +
    "<p><code>#{@name}</code> -- #{@tagline}</p>\n" +
    html
  end

  # Convert special format unordered lists to definition lists.
  def definition_list_filter(html)
    doc = Nokogiri::HTML(html)

    # process all unordered lists depth-first
    doc.xpath('//ul').to_a.reverse.each do |ul|
      items = ul.xpath('li')
      next if items.any? { |item| item.text.split("\n", 2).first !~ /:$/ }

      ul.name = 'dl'
      items.each do |item|
        if item.child.name == 'p'
          wrap = '<p></p>'
          container = item.child
        else
          wrap = '<dd></dd>'
          container = item
        end
        term, definition = container.inner_html.split(":\n", 2)

        dt = item.before("<dt>#{term}</dt>").previous_sibling
        dt['class'] = 'flush' if dt.content.length <= 10

        item.name = 'dd'
        container.swap(wrap.sub(/></, ">#{definition}<"))
      end
    end

    doc.css('html > body').inner_html
  end

  # Convert Ron HTML to roff.
  def roff_filter(html)
    doc = Nokogiri::HTML.fragment(html)
    @buf = []
    emit_document_head
    roff_block_filter(doc)
    write "\n"
    @buf.join.gsub(/\n{2,}/, "\n")
  end

  def roff_block_filter(node)
    prev = node.previous_sibling
    prev = prev.previous_sibling until prev.nil? || prev.element?
    comment "block: %p, following: %p" % [node.name, prev && prev.name]

    case node.name
    when '#document-fragment'
      node.children.each { |ch| roff_block_filter(ch) }
    when 'h2'
      macro "SH", quote(escape(node.content))
    when 'p'
      if prev && %w[dd li].include?(node.parent.name)
        macro "IP"
      elsif prev && !%w[h1 h2 h3].include?(prev.name)
        macro "P"
      end
      node.children.each { |ch| roff_inline_filter(ch) }
    when 'dl'
      macro "TP"
      node.children.each { |ch| roff_block_filter(ch) }
    when 'dt'
      macro "TP" unless prev.nil?
      node.children.each { |ch| roff_inline_filter(ch) }
      write "\n"
    when 'dd'
      if node.search('p').any?
        node.children.each { |ch| roff_block_filter(ch) }
      else
        node.children.each { |ch| roff_inline_filter(ch) }
      end
      write "\n"
    when 'pre'
      macro "nf"
      node.search('code').children.each { |ch| roff_inline_filter(ch) }
      macro "fi"
    when 'text'
      return if node.text =~ /^\s*$/m
      warn "unexpected text: %p",  node.text
    else
      warn "unrecognized block tag: %p", node.name
    end
  end

  def roff_inline_filter(node)
    case node.name
    when 'text'
      write escape(node.to_s.sub(/\n+$/, ' '))
    when 'code', 'b', 'strong'
      write '\fB'
      node.children.each { |ch| roff_inline_filter(ch) }
      write '\fR'
    when 'em', 'i', 'u'
      write '\fI'
      node.children.each { |ch| roff_inline_filter(ch) }
      write '\fR'
    when 'br'
      macro 'br'
    else
      warn "unrecognized inline tag: %p", node.name
    end
  end

protected
  def emit_document_head
    comment "generated by ron(1)"
    macro "TH", %[#{escape(name.upcase)} #{section} "BOTCEN DATE" "BOTLEF" "TOPCEN TITLE"]
  end

  def macro(name, value=nil)
    write "\n.\n.#{[name, value].compact.join(' ')}\n.\n"
  end

  def escape(text)
    text.gsub(/[\\-]/) { |m| "\\#{m}" }
  end

  def quote(text)
    "\"#{text}\""
  end

  def write(text)
    @buf << text
  end

  def comment(text)
    write %[\n.\\" #{text}\n]
  end

  def warn(text, *args)
    $stderr.puts "warn: #{text}" % args
  end
end
