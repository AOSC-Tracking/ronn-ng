#!/usr/bin/env ruby
## Usage: ronn <FILE >OUTPUT
##        ronn [OPTIONS] FILE...
##        ronn --man FILE ...
## Convert ronn source FILEs to roff or HTML manpage. In the first synopsis form,
## with no FILEs, read from standard input and write roff to standard output. With
## the second synopsis form, build HTML and roff output files based on input file
## names. In the third synopsis form, show ronn FILE like with man(1).
##
## Mode options alter the default file generating behavior:
##       --pipe                write to standard output instead of generating files
##   -m, --man                 show man page like with man(1)
##
## Format options control what files are generated. With no format options, both
## roff and HTML files are built:
##   -r, --roff                generate roff/mandoc output
##   -5, --html                generate entire HTML page with layout
##   -f, --fragment            generate HTML fragment instead of entire HTML page
##
## Document attributes:
##       --date=DATE           published date (YYYY-MM-DD format). displayed
##                             bottom-center in document footer
##       --manual=NAME         name of the manual this document belongs to;
##                             displayed top-center in header
##       --organization=NAME   publishing group, organization, or individual;
##                             displayed bottom-left in footer
##
## Misc options:
##   -w, --warnings            show troff warnings on stderr
##   -W                        disable previously enabled troff warnings
##       --help                show this help message
##
require 'date'
require 'optparse'

def info(message, *args)
  STDERR.puts message % args
end

def usage
  puts File.readlines(__FILE__).
    grep(/^##.*/).
    map { |line| line.chomp[3..-1] }.
    join("\n")
end

#
# Argument Parsing
#

build = true
view = false
formats = []
options = {}
groff = "groff -Wall -mtty-char -mandoc -Tascii"
pager = ENV['MANPAGER'] || ENV['PAGER'] || 'more'

ARGV.options do |option|
  # modes
  option.on("--pipe")           { build = false }
  option.on("-b", "--build")    { build = true }
  option.on("-m", "--man")      { build = false; view = true }
  option.on("-w", "--warnings") { groff += ' -ww' }
  option.on("-W")               { groff += ' -Ww' }

  # format options
  option.on("-r", "--roff")     { formats << 'roff' }
  option.on("-5", "--html")     { formats << 'html' }
  option.on("-f", "--fragment") { formats << 'html_fragment' }

  # manual attribute options
  [:name, :section, :manual, :organization, :date].each do |option_attr|
    option.on("--#{option_attr}=VALUE") { |val| options[option_attr] = val }
  end

  option.on_tail("--help") { usage ; exit 0 }
  option.parse!
end

if ARGV.empty? && STDIN.tty?
  usage
  exit 2
elsif ARGV.empty?
  # first synopsis form: write roff to standard output
  ARGV.push '-'
  build = false
  formats = %w[roff] if formats.empty?
elsif build
  formats = %w[roff html] if formats.empty?
elsif view
  formats = %w[roff] if formats.empty?
end

# turn the --date arg into a real date object
options[:date] &&= Date.strptime(options[:date], '%Y-%m-%d')

formats.delete('html') if formats.include?('html_fragment')
pid = nil

# Attempt to load dependencies, bringing in rubygems if we need it.
begin
  require 'hpricot'
  require 'rdiscount'
rescue LoadError
  if !defined?(Gem)
    warn "warn: #{$!.to_s}. trying again with rubygems."
    require 'rubygems'
    retry
  end
end

# Attempt to load ronn libs, setting up the load path if the require fails and
# we detect a development environment.
begin
  require 'ronn'
rescue LoadError
  raise if $!.to_s !~ /ronn/
  libdir = File.expand_path("../../lib", __FILE__).sub(/^#{Dir.pwd}/, '.')
  if !$:.include?(libdir)
    warn "warn: #{$!.to_s}. trying again with #{libdir} on load path."
    $:.unshift libdir
    retry
  end
  raise
end

wr = STDOUT
ARGV.each do |file|
  doc = Ronn.new(file, options) { file == '-' ? STDIN.read : File.read(file) }

  # setup the man pipeline if the --man option was specified
  if view && !build
    rd, wr = IO.pipe
    if pid = fork
      rd.close
    else
      wr.close
      STDIN.reopen rd
      exec "#{groff} | #{pager}"
    end
  end

  # write output for each format
  formats.each do |format|
    if build
      path = doc.path_for(format)
      info "#{format}: #{path}" if build
      output = doc.convert(format)
      File.open(path, 'wb') { |f| f.puts(output) }
      if format == 'roff'
        if view
          system "man #{path}"
        else
          system "#{groff} <#{path} >/dev/null"
        end
      end
    else
      output = doc.convert(format)
      wr.puts(output)
    end
  end

  if pid
    wr.close
    Process.wait
  end
end
